<script src="habitat-embed.js"></script>
<script>Habitat.install(this)</script>
<script>

const stage = Stage.make()

const {canvas, context} = stage

const TIMELINE_LENGTH = 30
const timeline = []
for (let i = 0; i < TIMELINE_LENGTH; i++) {
	timeline.push({number: i+1})
}
for (const time of timeline) {
	const img = document.createElement("img")
	img.src = `images/${time.number}.jpg`
	time.img = img
}

const plane = document.createElement("img")
plane.src = `images/plane.png`

on.load(() => {
	
	document.body.style["margin"] = "0px"
	document.body.appendChild(canvas)
	trigger("resize")
	setInterval(stage.tick, 1000 / 60)
	
})

on.resize(() => {
	
	canvas.width = innerWidth
	canvas.height = innerHeight
	canvas.style["width"] = innerWidth
	canvas.style["height"] = innerHeight
	canvas.style["background-color"] = Colour.Black
	
})

const COLOURS = [
	Colour.Red,
	Colour.Green,
	Colour.Blue,
	Colour.Rose,
	Colour.Pink,
	Colour.Yellow,
	Colour.Cyan,
	Colour.Orange,
	Colour.Purple,
]
	
let starId = 0
const makeStar = () => {
	const colour = COLOURS[Math.floor(Math.random() * COLOURS.length)]
	const direction = Math.random() * 2*Math.PI
	return {colour, x: canvas.width/2, y: canvas.height/2, direction, speed: SPEED, speedMod: 1.005, age: 0, id: starId++}
}

const stars = new Set()
const MAX_STARS = Infinity
const SPEED = 0.2
const TRAIL_LENGTH = 10

let r = 0.4
const spawnStars = () => {

	if (Math.random() < r && stars.size < MAX_STARS) {
		const star = makeStar()
		stars.add(star)
		spawnStars()
	}
}

const MARGIN_TEST = 10

const KILL_ZONE = 100
const THUMB_SIZE = 0.004

let GROWTH = 0.07

let paused = true

on.keydown(e => {
	if (e.key === " ") paused = !paused
}) 

stage.tick = () => {

	if (paused) return

	context.clearRect(0, 0, canvas.width, canvas.height)
	//r += (1-r) * 0.001
	//r += 0.0005
	//if (r > 0.9) r = 0.0
	//GROWTH += 0.001
	//if (starId < 30) spawnStars()
	spawnStars()

	context.lineCap = "round"
	for (const star of [...stars.values()].reverse()) {
		
		//context.strokeStyle = star.colour
		
		star.direction += 0.0003 * star.age

		const tx = star.x + star.speed*TRAIL_LENGTH * Math.cos(star.direction)
		const ty = star.y + star.speed*TRAIL_LENGTH * Math.sin(star.direction)
			  
		/*if (star.age !== 0) {
			context.lineWidth = star.age
			context.beginPath()
			context.moveTo(star.x, star.y)
			context.lineTo(tx, ty)
			context.stroke()
		}*/
		
		const nx = star.x + star.speed * Math.cos(star.direction)
		const ny = star.y + star.speed * Math.sin(star.direction)
		
		const ep = (star.id % 30)

		const img = plane
		const width = img.width * star.age * THUMB_SIZE
		const height = img.height * star.age * THUMB_SIZE

		const x = nx-width/2
		const y = ny-height/2

		const rotation = star.direction

		context.translate(nx, ny)
		context.rotate(rotation)
		context.translate(-nx, -ny)

		context.drawImage(img, x, y, width, height)

		context.translate(nx, ny)
		context.rotate(-rotation)
		context.translate(-nx, -ny)

		star.x = nx
		star.y = ny
		star.speed *= star.speedMod
		star.age += GROWTH
		
		if (star.x < -KILL_ZONE || star.x > canvas.width+KILL_ZONE || star.y < -KILL_ZONE || star.y > canvas.height+KILL_ZONE) {
			stars.delete(star)
		}

		if (star.speed < 0.15) {
			star.speedMod = 1.05
		}

		if (star.speed > SPEED * 2) {
			//star.speedMod = 0.99
		}
	}
	
	//context.fillStyle = Colour.Grey
	//context.fillRect(canvas.width/MARGIN_TEST, canvas.height/MARGIN_TEST, canvas.width-canvas.width/MARGIN_TEST*2, canvas.height-canvas.height/MARGIN_TEST*2)
	
}




</script>